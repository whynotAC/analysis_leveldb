// Decodes the blocks generated by block_builder.cc

#include "table/block.h"

#include <algorithm>
#include <vector>

#include "leveldb/comparator.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

namespace leveldb {

inline uint32_t Block::NumRestarts() const {
    assert(size_ >= sizeof(uint32_t));
    return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

Block::Block(const BlockContents& contents)
        : data_(contents.data.data()),
          size_(contents.data.size()),
          owned_(contents.heap_allocated) {
    if (size_ < sizeof(uint32_t)) {
        size_ = 0;      // Error marker
    } else {
        size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);
        if (NumRestarts() > max_restarts_allowed) {
            // The size is too small for NumRestarts()
            size_ = 0;
        } else {
            restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
        }
    }
}

Block::~Block() {
    if (owned_) {
        delete[] data_;
    }
}

// Helper routine: decode the next block entry starting at "p".
// storing the number of shared key bytes, non_shared key bytes.
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively. Will not dereference past "limit".
//
// If any errors are detected, returns nullptr. Otherwise, returns a
// pointer to the key delta (just past the three decoded values)
static inline const char* DecodeEntry(const char* p, const char* limit,
                                        uint32_t* shared, uint32_t* non_shared,
                                        uint32_t* value_length) {
    if (limit - p < 3) return nullptr;
    *shared = reinterpret_cast<const unsigned char*>(p)[0];
    *non_shared = reinterpret_cast<const unsigned char*>(p)[1];
    *value_length = reinterpret_cast<const unsigned char*>(p)[2];
    if ((*shared | * non_shared | *value_length) < 128) {
        // Fast path: all three values are encoded in on byte each
        p += 3;
    } else {
        if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
        if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
        if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
    }

    if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
        return nullptr;
    }
    return p;
}

class Block::Iter : public Iterator {
  private:
    const Comparator* const comparator_;
    const char* const data_;        // underlying block contents
    uint32_t const restarts_;       // Offset of restart array (list of fixed32)
    uint32_t const num_restarts_;   // Number of uint32_t entries in restart array

    // current_ is offset in data_ of current entry. >= restarts_ if !Valid
    uint32_t current_;
    uint32_t restart_index_;    // Index of restart block in which current_ falls
    std::string key_;
    Slice value_;
    Status status_;

    inline int Compare(const Slice& a, const Slice& b) const {
        return comparator_->Compare(a, b);
    }

    // Return the offset in data_ just past the end of the current entry.
    inline uint32_t NextEntryOffset() const {
        return (value_.data() + value_.size()) - data_;
    }

    uint32_t GetRestartPoint(uint32_t index) {
        assert(index < num_restarts_);
        return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
    }

    void SeekToRestartPoint(uint32_t index) {
        key_.clear();
        restart_index_ = index;
        // Current_ will be fixed by ParseNextKey()
        //
        // ParseNextKey() starts at the end of value_, so set value_ accordingly
        uint32_t offset = GetRestartPoint(index);
        value_ = Slice(data_ + offset, 0);
    }

  public:
    Iter(const Comparator* comparator, const char* data, uint32_t restarts,
            uint32_t num_restarts)
            : comparator_(comparator),
              data_(data),
              restarts_(restarts),
              num_restarts_(num_restarts),
              current_(restarts_),
              restart_index_(num_restarts_) {
        assert(num_restarts_ > 0);
    }

    virtual bool Valid() const { return current_ < restarts_; }
    virtual Status status() const { return status_; }
    virtual Slice key() const {
        assert(Valid());
        return key_;
    }
    virtual Slice value() const {
        assert(Valid());
        return value_;
    }

    virtual void Next() {
        assert(Valid());
        ParseNextKey();
    }

};

} // namespace leveldb
